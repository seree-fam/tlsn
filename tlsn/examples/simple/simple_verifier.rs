use std::{str, time::Duration};

use elliptic_curve::pkcs8::DecodePublicKey;
use ethers::types::{U256, H256};
use sha2::{Digest, Sha256};
use elliptic_curve::sec1::ToEncodedPoint;
use mpz_core::serialize::CanonicalSerialize;
use tracing::debug;
use tlsn_core::proof::{SessionProof, TlsProof};
use tlsn_core::Signature;

/// A simple verifier which reads a proof generated by `simple_prover.rs` from "proof.json", verifies
/// it and prints the verified data to the console.
fn main() {
    // Deserialize the proof
    let proof = std::fs::read_to_string("simple_proof.json").unwrap();
    let proof: TlsProof = serde_json::from_str(proof.as_str()).unwrap();

    let TlsProof {
        // The session proof establishes the identity of the server and the commitments
        // to the TLS transcript.
        session,
        // The substrings proof proves select portions of the transcript, while redacting
        // anything the Prover chose not to disclose.
        substrings,
    } = proof;

    let key = notary_pubkey();
    let key_coords: Coords = collect_coords(key).expect("Failed to collect key coordinates");

    // Verify the session proof against the Notary's public key
    //
    // This verifies the identity of the server using a default certificate verifier which trusts
    // the root certificates from the `webpki-roots` crate.
    session
        .verify_with_default_cert_verifier(notary_pubkey())
        .unwrap();

    let SessionProof {
        // The session header that was signed by the Notary is a succinct commitment to the TLS transcript.
        header,
        signature,
        // This is the session_info, which contains the server_name, that is checked against the
        // certificate chain shared in the TLS handshake.
        session_info,
        ..
    } = session;

    let header_bytes = header.to_bytes();
    debug!("Header bytes: {:?}", header_bytes);

    let header_hash = sha2_hash(&header_bytes);

    assert_eq!(header_hash.len(), 32);

    let mut hash_array = [0u8; 32];
    hash_array.copy_from_slice(&header_hash);

    let bytes32_hash = H256::from(hash_array);

    let mut r_u256: Option<U256> = None;
    let mut s_u256: Option<U256> = None;

    match signature {
        Some(Signature::P256(p256_signature)) => {
            let r_bytes = p256_signature.r().to_bytes();
            let s_bytes = p256_signature.s().to_bytes();

            // Convert FieldBytes to U256
            r_u256 = Some(U256::from_big_endian(r_bytes.as_slice()));
            s_u256 = Some(U256::from_big_endian(s_bytes.as_slice()));

            if let (Some(r_value), Some(s_value)) = (r_u256, s_u256) {
                println!("r: {:?}, s: {:?}", r_value, s_value);
            }
        }
        _ => {
            println!("Signature is not P256");
        }
    }

    if r_u256.is_none() || s_u256.is_none() {
        println!("r or s was not set.");
    }

    // The time at which the session was recorded
    let time = chrono::DateTime::UNIX_EPOCH + Duration::from_secs(header.time());

    // Verify the substrings proof against the session header.
    //
    // This returns the redacted transcripts
    let (mut sent, mut recv) = substrings.verify(&header).unwrap();

    // Replace the bytes which the Prover chose not to disclose with 'X'
    sent.set_redacted(b'X');
    recv.set_redacted(b'X');

    println!("-------------------------------------------------------------------");
    println!(
        "Successfully verified that the bytes below came from a session with {:?} at {}.",
        session_info.server_name, time
    );
    println!("Note that the bytes which the Prover chose not to disclose are shown as X.");
    println!();
    println!("Bytes sent:");
    println!();
    print!("{}", String::from_utf8(sent.data().to_vec()).unwrap());
    println!();
    println!("Bytes received:");
    println!();
    println!("{}", String::from_utf8(recv.data().to_vec()).unwrap());
    println!("-------------------------------------------------------------------");

    let mut arr: U256 = U256([0u64; 4]);
    let mut ess: U256 = U256([0u64; 4]);

    match r_u256 {
        Some(value) => {
            arr = value;
        }
        _ => {
            debug!("Something is up with the r value.")
        }
    }

    match s_u256 {
        Some(value) => {
            ess = value;
        }
        _ => {
            debug!("Something is up with the s value.")
        }
    }

    let verification_result =
        VerificationResult::new(bytes32_hash, arr, ess, key_coords.x(), key_coords.y());

    println!("Verification result: {:?}", verification_result);
}

/// Returns a Notary pubkey trusted by this Verifier
fn notary_pubkey() -> p256::PublicKey {
    let pem_file = str::from_utf8(include_bytes!(
        "../../../notary/server/fixture/notary/notary.pub"
    ))
    .unwrap();
    p256::PublicKey::from_public_key_pem(pem_file).unwrap()
}

pub(crate) fn collect_coords(key: p256::PublicKey) -> Option<Coords> {
    let encoded_point = key.to_encoded_point(false);

    let x_bytes = encoded_point.x()?;
    let y_bytes = encoded_point.y()?;

    let x_u256 = U256::from_big_endian(x_bytes.as_slice());
    let y_u256 = U256::from_big_endian(y_bytes.as_slice());

    Some(Coords { x: x_u256, y: y_u256 })
}

fn sha2_hash(data: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VerificationResult {
    pub message_hash: H256,
    pub r: U256,
    pub s: U256,
    pub x: U256,
    pub y: U256,
}

impl VerificationResult {
    pub fn new(message_hash: H256, r: U256, s: U256, x: U256, y: U256) -> Self {
        VerificationResult {
            message_hash,
            r,
            s,
            x,
            y,
        }
    }

    pub fn default() -> Self {
        VerificationResult {
            message_hash: H256([0u8; 32]),
            r: U256([0u64; 4]),
            s: U256([0u64; 4]),
            x: U256([0u64; 4]),
            y: U256([0u64; 4]),
        }
    }

    pub fn message_hash(&self) -> &H256 {
        &self.message_hash
    }

    pub fn set_message_hash(&mut self, message_hash: H256) {
        self.message_hash = message_hash;
    }

    pub fn r(&self) -> U256 {
        self.r
    }

    pub fn set_r(&mut self, r: U256) {
        self.r = r;
    }

    pub fn s(&self) -> U256 {
        self.s
    }

    pub fn set_s(&mut self, s: U256) {
        self.s = s;
    }

    pub fn x(&self) -> U256 {
        self.x
    }

    pub fn set_x(&mut self, x: U256) {
        self.x = x;
    }

    pub fn y(&self) -> U256 {
        self.y
    }

    pub fn set_y(&mut self, y: U256) {
        self.y = y;
    }
}

pub struct Coords {
    pub x: U256,
    pub y: U256,
}

impl Coords {
    pub fn new(x: U256, y: U256) -> Self {
        Coords { x, y }
    }

    pub fn x(&self) -> U256 {
        self.x
    }

    pub fn y(&self) -> U256 {
        self.y
    }
}